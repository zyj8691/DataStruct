#include"stdio.h"

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20 /*  存储空间初始分配量 */


typedef int Status;
typedef int SElemType; /* SElemType 类型根据实际情况而定，这里假设为 int */

typedef struct StackNode
{
	SElemType data;
	struct StackNode* next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
	LinkStackPtr top;
	int count;
}LinkStack;

/*构造一个空栈S*/
Status InitStack(LinkStack *S)
{
	S->top = (LinkStackPtr)malloc(sizeof(StackNode));
	if (!S->top)
		return ERROR;
	S->top = NULL;
	S->count = 0;
	return OK;
}
/*把S置为空栈*/
Status ClearStack(LinkStack *S)
{
	LinkStackPtr p, q;
	p = S->top;
	while (p)
	{
		q = p;
		p = p->next;
		free(q);
	}
	S->count = 0;
	return OK;
}

/* 若栈S为空栈，则返回TRUE，否则返回FALSE*/
Status StackEmpty(LinkStack S)
{
	if (S.count == 0)
		return TRUE;
	else

		return FALSE;
}

/* 返回S的元素个数,即栈的长度*/
int StackLength(LinkStack S)
{
	return S.count;
}

/* 若栈不空，则用 e 返回 S 的栈顶元素，并返回 OK；否则返回 ERROR */
Status GetTop(LinkStack S, SElemType *e)
{
	if (S.top == NULL)
		return ERROR;
	else
		*e = S.top->data;
	return OK;
}

/*插入元素e为新的栈顶元素*/
Status Push(LinkStack *S, SElemType e)
{
	LinkStackPtr n = (LinkStackPtr)malloc(sizeof(StackNode));
	n->data = e;
	n->next = S->top;/* 把当前的栈顶元素赋值给新结点的直接后继 */ 
	S->top = n;		/* 将新的结点n赋值给栈顶指针 */
	S->count++;
	return OK;
}
/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/
Status Pop(LinkStack *S, SElemType *e)
{
	LinkStackPtr p;
	if (StackEmpty(*S))
		return ERROR;
	*e = S->top->data;
	p = S->top;	/*将栈顶结点赋值给p*/
	S->top = S->top->next;	/*使得栈顶指针下移一位，指向后一结点*/
	free(p);	/*释放结点p*/
	S->count--;
	return OK;
}

int main()
{
	
	
	return 0;
}